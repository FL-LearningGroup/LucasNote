# 总结
1. 区分设计中的责任 ---> 根据单一原则确定类 ---> 找出可变部分，进行封装

# OO 基础

+ 抽象
+ 封装
+ 继承
+ 多态

# OO 原则

1. 区分设计中的责任。

2. 找出应用中可能变化之处，将可变之处与不变之处独立开，降低对不变之处的影响。

3. 针对接口编程，而不是针对实现编程。

4. 多用组合(行为可变化), 少用继承(行为绑定)。

5. 降低交互对象之间的松耦合。

6. 类应该对扩展开放，对修改关闭。

7. 依赖倒置: 依赖抽象，不要依赖具体类。原则说明, 不能让高层组件依赖低层组件，而且，不管高层或者底层组件，“两者”都应该依赖抽象。
    遵循原则:
    + 变量不可以持有具体类。
    + 不要让类派生自具体类。
    + 不要覆盖基类中已现实的方法。

8. 最少知道原则，减少依赖类的数目。
   遵循原则，在该对象的方法内，我们只应该调用属于以下范围的方法:
   
   + 该对象本身
   + 被当做方法的参数而传递进来的对象
   + 此方法所创建或实例化的任何对象
   + 对象的任何组件

9. 别找我，我会主动找你，由超类控制一切。

10. 单一原则， 一个类应该只有一个引起变化的原因。 

# OO 模式

1. 策略模式: 定义算法族，分别封装起来，让他们之间可以相互替换。(鸭子模型)

2. 观察者模式: 定义对象之间一对多的依赖关系，当对象改变时，它的所有依赖者都会自动收到通知。(天气仪表盘通知）

3. 装饰者模式: 在运行时，动态的将责任附加到对象上，装饰者提供了比继承更有弹性的替代方案(应用继承了基类的类型而不是行为)。(咖啡订单系统)
    + 增加类，及其创建对象的复杂度。
    ```java
      InputStream in = new LowerCaseInputStream(
                            new BufferedInputStream(
                                  new FileInputStream("test.txt")
                                )
                           );
    ```

4. 工厂方法模式： 定义创建对象的接口，由子类决定实例化的对象。(披萨下单)

5. 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。其任务是定义一个负责创建一组产品的接口。

    **工厂方法 VS 抽象工厂**

    + 工厂方法利用继承
    + 抽象工厂利用组合

6. 单例模式：确保一个类只有一个实例，并提供一个全局访问点。

7. 命令模式: 将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其它对象。**命令模式也支持可撤销操作。**

8. 适配器模式: 将一个类的接口(功能), 转换为客户期望的另一个接口。适配器让原本接口不兼容的类可以合作。

9. 外观模式: 将一个涉及到多个类的方法调用的功能，封装成一个简单的接口。接口隐藏了多个类方法的调用。

10. 模板方法模式: 在一个方法中定义算法框架，而将一些算法的实现延迟到子类中。模板方法使得子类可以在不改变算法结构情况下，重新定义算法中的某些步骤。
    VS 策略模式: 策略模式定义一个算法家族，并让这些算法可以互换。

11. 迭代器模式: 为集合定义公共的遍历接口，简化遍历，不暴露集合内部的元素。

12. 组合模式: 将对象组合成树形结构来表现“整体/部分" 层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
    当有数个对象集合，他们彼此之间有“整体/部分”的关系时，就可以使用组合模式。

13. 状态模式: 对象内部维护状态变量。通过改变状态变量，改变类的行为。通过将状态封装为类。

14. 代理模式: 为另一个对象提供一个替身或占位符以控制这个对象的访问。

# 重要语句

1. 继承接口无法达到代码复用。

2. 专有名词(词汇)的威力。当使用词汇与其它人员交流时，词汇代表的是其背后所象征的质量，特征，约束及其思想。

3. 库与框架无法帮助我们将应用程序组成成容易了解，容易维护，具有弹性的框架，所以需要设计模式。

4. 建立可维护的OO系统。要诀就在于随时想到系统以后可能需要的变化以及应付变化的原则。

5. 运行时的扩展，远比编译时期的继承威力大。

6. **找到代码中有可能改变的地方。**

7. 针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。

8. 随着系统的增长，随时观察有没有迹象显示某个类改变的原因超出了一个。

9. 当一个类或一个模块被设计只支持一组相关的功能时。就具有高内聚。

10. 有时候用好的OO设计原则就可以解决问题。
